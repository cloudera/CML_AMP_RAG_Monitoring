// Code generated by go-swagger; DO NOT EDIT.

package restapi

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/Stratoscale/swagger/query"
	"github.com/go-openapi/errors"
	"github.com/go-openapi/loads"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	lhttp "github.infra.cloudera.com/CAI/AmpRagMonitoring/pkg/http"
	swaggerinterceptors "github.infra.cloudera.com/CAI/AmpRagMonitoring/pkg/swagger/interceptors"

	"github.infra.cloudera.com/CAI/AmpRagMonitoring/models"
	"github.infra.cloudera.com/CAI/AmpRagMonitoring/restapi/operations/experiments"
	"github.infra.cloudera.com/CAI/AmpRagMonitoring/restapi/operations/metrics"
	"github.infra.cloudera.com/CAI/AmpRagMonitoring/restapi/operations/runs"

	operations "github.infra.cloudera.com/CAI/AmpRagMonitoring/restapi/operations"
)

type contextKey string

const AuthKey contextKey = "Auth"

//go:generate mockery -name ExperimentsAPI -inpkg

// ExperimentsAPI
type ExperimentsAPI interface {
	// GetExperiments is Fetch the list of monitored experiments
	GetExperiments(ctx context.Context, params experiments.GetExperimentsParams) (*experiments.GetExperimentsOK, *lhttp.HttpError)
	Shutdown() error
}

//go:generate mockery -name MetricsAPI -inpkg

// MetricsAPI
type MetricsAPI interface {
	// GetMetricsNames is List monitoring metric names for an experiment
	GetMetricsNames(ctx context.Context, params metrics.GetMetricsNamesParams) (*metrics.GetMetricsNamesOK, *lhttp.HttpError)
	// PostMetrics is Create monitoring metrics
	PostMetrics(ctx context.Context, params metrics.PostMetricsParams) (*metrics.PostMetricsOK, *lhttp.HttpError)
	// PostMetricsList is List monitoring metrics
	PostMetricsList(ctx context.Context, params metrics.PostMetricsListParams) (*metrics.PostMetricsListOK, *lhttp.HttpError)
	Shutdown() error
}

//go:generate mockery -name RunsAPI -inpkg

// RunsAPI
type RunsAPI interface {
	// DeleteRuns is Delete an experiment run from monitoring.
	DeleteRuns(ctx context.Context, params runs.DeleteRunsParams) (*runs.DeleteRunsOK, *lhttp.HttpError)
	// PostRuns is Register an experiment run for monitoring
	PostRuns(ctx context.Context, params runs.PostRunsParams) (*runs.PostRunsOK, *lhttp.HttpError)
	// PostRunsList is Get a list monitored experiment runs for an experiment.
	PostRunsList(ctx context.Context, params runs.PostRunsListParams) (*runs.PostRunsListOK, *lhttp.HttpError)
	Shutdown() error
}

// Config is configuration for Handler
type Config struct {
	ExperimentsAPI
	MetricsAPI
	RunsAPI
	Logger func(string, ...interface{})
	// InnerMiddleware is for the handler executors. These do not apply to the swagger.json document.
	// The middleware executes after routing but before authentication, binding and validation
	InnerMiddleware func(http.Handler) http.Handler

	// Middleware *sbswagger.MiddlewareWrapper
	Interceptors []swaggerinterceptors.UnaryServerInterceptor

	// Authorizer is used to authorize a request after the Auth function was called using the "Auth*" functions
	// and the principal was stored in the context in the "AuthKey" context value.
	Authorizer func(*http.Request) error
}

// Handler returns an http.Handler given the handler configuration
// It mounts all the business logic implementers in the right routing.
func Handler(c Config) (http.Handler, error) {
	spec, err := loads.Analyzed(swaggerCopy(SwaggerJSON), "")
	if err != nil {
		return nil, fmt.Errorf("analyze swagger: %v", err)
	}
	api := operations.NewMetricsAPI(spec)
	api.ServeError = errors.ServeError
	api.Logger = c.Logger

	api.JSONConsumer = runtime.JSONConsumer()
	api.JSONProducer = runtime.JSONProducer()
	{
		info := &swaggerinterceptors.UnaryServerInfo{
			FullMethod: "Runs/DeleteRuns", // TODO: add full package
		}

		baseHandler := func(ctx context.Context, header http.Header, req interface{}) (interface{}, *lhttp.HttpError) {
			typedParams := req.(runs.DeleteRunsParams)
			resp, herr := c.RunsAPI.DeleteRuns(ctx, typedParams)
			return resp, herr
		}

		for i := len(c.Interceptors) - 1; i >= 0; i-- {
			interceptor := c.Interceptors[i]
			currentHandler := baseHandler
			baseHandler = func(ctx context.Context, header http.Header, req interface{}) (interface{}, *lhttp.HttpError) {
				return interceptor(ctx, header, req, info, currentHandler)
			}
		}

		api.RunsDeleteRunsHandler = runs.DeleteRunsHandlerFunc(func(params runs.DeleteRunsParams) middleware.Responder {
			resp, herr := baseHandler(params.HTTPRequest.Context(), params.HTTPRequest.Header, params)
			if herr != nil {
				return herr
			}
			return resp.(middleware.Responder)
		})
	}

	{
		info := &swaggerinterceptors.UnaryServerInfo{
			FullMethod: "Experiments/GetExperiments", // TODO: add full package
		}

		baseHandler := func(ctx context.Context, header http.Header, req interface{}) (interface{}, *lhttp.HttpError) {
			typedParams := req.(experiments.GetExperimentsParams)
			resp, herr := c.ExperimentsAPI.GetExperiments(ctx, typedParams)
			return resp, herr
		}

		for i := len(c.Interceptors) - 1; i >= 0; i-- {
			interceptor := c.Interceptors[i]
			currentHandler := baseHandler
			baseHandler = func(ctx context.Context, header http.Header, req interface{}) (interface{}, *lhttp.HttpError) {
				return interceptor(ctx, header, req, info, currentHandler)
			}
		}

		api.ExperimentsGetExperimentsHandler = experiments.GetExperimentsHandlerFunc(func(params experiments.GetExperimentsParams) middleware.Responder {
			resp, herr := baseHandler(params.HTTPRequest.Context(), params.HTTPRequest.Header, params)
			if herr != nil {
				return herr
			}
			return resp.(middleware.Responder)
		})
	}

	{
		info := &swaggerinterceptors.UnaryServerInfo{
			FullMethod: "Metrics/GetMetricsNames", // TODO: add full package
		}

		baseHandler := func(ctx context.Context, header http.Header, req interface{}) (interface{}, *lhttp.HttpError) {
			typedParams := req.(metrics.GetMetricsNamesParams)
			resp, herr := c.MetricsAPI.GetMetricsNames(ctx, typedParams)
			return resp, herr
		}

		for i := len(c.Interceptors) - 1; i >= 0; i-- {
			interceptor := c.Interceptors[i]
			currentHandler := baseHandler
			baseHandler = func(ctx context.Context, header http.Header, req interface{}) (interface{}, *lhttp.HttpError) {
				return interceptor(ctx, header, req, info, currentHandler)
			}
		}

		api.MetricsGetMetricsNamesHandler = metrics.GetMetricsNamesHandlerFunc(func(params metrics.GetMetricsNamesParams) middleware.Responder {
			resp, herr := baseHandler(params.HTTPRequest.Context(), params.HTTPRequest.Header, params)
			if herr != nil {
				return herr
			}
			return resp.(middleware.Responder)
		})
	}

	{
		info := &swaggerinterceptors.UnaryServerInfo{
			FullMethod: "Metrics/PostMetrics", // TODO: add full package
		}

		baseHandler := func(ctx context.Context, header http.Header, req interface{}) (interface{}, *lhttp.HttpError) {
			typedParams := req.(metrics.PostMetricsParams)
			resp, herr := c.MetricsAPI.PostMetrics(ctx, typedParams)
			return resp, herr
		}

		for i := len(c.Interceptors) - 1; i >= 0; i-- {
			interceptor := c.Interceptors[i]
			currentHandler := baseHandler
			baseHandler = func(ctx context.Context, header http.Header, req interface{}) (interface{}, *lhttp.HttpError) {
				return interceptor(ctx, header, req, info, currentHandler)
			}
		}

		api.MetricsPostMetricsHandler = metrics.PostMetricsHandlerFunc(func(params metrics.PostMetricsParams) middleware.Responder {
			resp, herr := baseHandler(params.HTTPRequest.Context(), params.HTTPRequest.Header, params)
			if herr != nil {
				return herr
			}
			return resp.(middleware.Responder)
		})
	}

	{
		info := &swaggerinterceptors.UnaryServerInfo{
			FullMethod: "Metrics/PostMetricsList", // TODO: add full package
		}

		baseHandler := func(ctx context.Context, header http.Header, req interface{}) (interface{}, *lhttp.HttpError) {
			typedParams := req.(metrics.PostMetricsListParams)
			resp, herr := c.MetricsAPI.PostMetricsList(ctx, typedParams)
			return resp, herr
		}

		for i := len(c.Interceptors) - 1; i >= 0; i-- {
			interceptor := c.Interceptors[i]
			currentHandler := baseHandler
			baseHandler = func(ctx context.Context, header http.Header, req interface{}) (interface{}, *lhttp.HttpError) {
				return interceptor(ctx, header, req, info, currentHandler)
			}
		}

		api.MetricsPostMetricsListHandler = metrics.PostMetricsListHandlerFunc(func(params metrics.PostMetricsListParams) middleware.Responder {
			resp, herr := baseHandler(params.HTTPRequest.Context(), params.HTTPRequest.Header, params)
			if herr != nil {
				return herr
			}
			return resp.(middleware.Responder)
		})
	}

	{
		info := &swaggerinterceptors.UnaryServerInfo{
			FullMethod: "Runs/PostRuns", // TODO: add full package
		}

		baseHandler := func(ctx context.Context, header http.Header, req interface{}) (interface{}, *lhttp.HttpError) {
			typedParams := req.(runs.PostRunsParams)
			resp, herr := c.RunsAPI.PostRuns(ctx, typedParams)
			return resp, herr
		}

		for i := len(c.Interceptors) - 1; i >= 0; i-- {
			interceptor := c.Interceptors[i]
			currentHandler := baseHandler
			baseHandler = func(ctx context.Context, header http.Header, req interface{}) (interface{}, *lhttp.HttpError) {
				return interceptor(ctx, header, req, info, currentHandler)
			}
		}

		api.RunsPostRunsHandler = runs.PostRunsHandlerFunc(func(params runs.PostRunsParams) middleware.Responder {
			resp, herr := baseHandler(params.HTTPRequest.Context(), params.HTTPRequest.Header, params)
			if herr != nil {
				return herr
			}
			return resp.(middleware.Responder)
		})
	}

	{
		info := &swaggerinterceptors.UnaryServerInfo{
			FullMethod: "Runs/PostRunsList", // TODO: add full package
		}

		baseHandler := func(ctx context.Context, header http.Header, req interface{}) (interface{}, *lhttp.HttpError) {
			typedParams := req.(runs.PostRunsListParams)
			resp, herr := c.RunsAPI.PostRunsList(ctx, typedParams)
			return resp, herr
		}

		for i := len(c.Interceptors) - 1; i >= 0; i-- {
			interceptor := c.Interceptors[i]
			currentHandler := baseHandler
			baseHandler = func(ctx context.Context, header http.Header, req interface{}) (interface{}, *lhttp.HttpError) {
				return interceptor(ctx, header, req, info, currentHandler)
			}
		}

		api.RunsPostRunsListHandler = runs.PostRunsListHandlerFunc(func(params runs.PostRunsListParams) middleware.Responder {
			resp, herr := baseHandler(params.HTTPRequest.Context(), params.HTTPRequest.Header, params)
			if herr != nil {
				return herr
			}
			return resp.(middleware.Responder)
		})
	}

	api.ServerShutdown = func() {}
	return api.Serve(c.InnerMiddleware), nil
}

// Query parse functions for all the models
// Those can be used to extract database query from the http path's query string
var (
	ExperimentQueryParse              = query.MustNewBuilder(&query.Config{Model: models.Experiment{}}).ParseRequest
	ExperimentRunQueryParse           = query.MustNewBuilder(&query.Config{Model: models.ExperimentRun{}}).ParseRequest
	ExperimentRunListFilterQueryParse = query.MustNewBuilder(&query.Config{Model: models.ExperimentRunListFilter{}}).ParseRequest
	MetricQueryParse                  = query.MustNewBuilder(&query.Config{Model: models.Metric{}}).ParseRequest
	MetricListFilterQueryParse        = query.MustNewBuilder(&query.Config{Model: models.MetricListFilter{}}).ParseRequest
	MetricTagQueryParse               = query.MustNewBuilder(&query.Config{Model: models.MetricTag{}}).ParseRequest
	MetricValueQueryParse             = query.MustNewBuilder(&query.Config{Model: models.MetricValue{}}).ParseRequest
	MetricsQueryParse                 = query.MustNewBuilder(&query.Config{Model: models.Metrics{}}).ParseRequest
)

// swaggerCopy copies the swagger json to prevent data races in runtime
func swaggerCopy(orig json.RawMessage) json.RawMessage {
	c := make(json.RawMessage, len(orig))
	copy(c, orig)
	return c
}

// authorizer is a helper function to implement the runtime.Authorizer interface.
type authorizer func(*http.Request) error

func (a authorizer) Authorize(req *http.Request, principal interface{}) error {
	if a == nil {
		return nil
	}
	ctx := storeAuth(req.Context(), principal)
	return a(req.WithContext(ctx))
}

func storeAuth(ctx context.Context, principal interface{}) context.Context {
	return context.WithValue(ctx, AuthKey, principal)
}
